// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: wallet.sql

package db

import (
	"context"
	"database/sql"
)

const clearPrimaryWallet = `-- name: ClearPrimaryWallet :exec

UPDATE wallets
SET is_primary = false, updated_at = NOW()
WHERE user_id = ? AND is_primary = true
`

// ============================================================================
// Primary 지갑 설정 (트랜잭션 내 호출)
// ============================================================================
// 기존 Primary 지갑 해제 (SetPrimary 트랜잭션 첫 단계)
func (q *Queries) ClearPrimaryWallet(ctx context.Context, userID uint64) error {
	_, err := q.db.ExecContext(ctx, clearPrimaryWallet, userID)
	return err
}

const countWalletsByUser = `-- name: CountWalletsByUser :one
SELECT COUNT(*) as total FROM wallets
WHERE user_id = ?
`

// 사용자의 지갑 수 조회
func (q *Queries) CountWalletsByUser(ctx context.Context, userID uint64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countWalletsByUser, userID)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const createWallet = `-- name: CreateWallet :execresult

INSERT INTO wallets (external_id, user_id, address, label, is_primary, is_verified)
VALUES (?, ?, ?, ?, false, false)
`

type CreateWalletParams struct {
	ExternalID string         `json:"external_id"`
	UserID     uint64         `json:"user_id"`
	Address    string         `json:"address"`
	Label      sql.NullString `json:"label"`
}

// ============================================================================
// Wallet Queries - Phase 1
// ============================================================================
// NOTE: wallet address는 저장/조회 시 lower-case normalize 적용
//
//	서비스 레이어에서 strings.ToLower() 처리 후 쿼리 호출
//
// 지갑 등록 (address는 서비스에서 lower-case 변환 후 전달)
// is_verified=false, is_primary=false 기본값
func (q *Queries) CreateWallet(ctx context.Context, arg CreateWalletParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createWallet,
		arg.ExternalID,
		arg.UserID,
		arg.Address,
		arg.Label,
	)
}

const existsVerifiedWalletByUser = `-- name: ExistsVerifiedWalletByUser :one
SELECT EXISTS(
    SELECT 1 FROM wallets WHERE user_id = ? AND is_verified = true
) as exists_flag
`

// 사용자의 검증된 지갑 존재 여부
func (q *Queries) ExistsVerifiedWalletByUser(ctx context.Context, userID uint64) (bool, error) {
	row := q.db.QueryRowContext(ctx, existsVerifiedWalletByUser, userID)
	var exists_flag bool
	err := row.Scan(&exists_flag)
	return exists_flag, err
}

const existsWalletByAddress = `-- name: ExistsWalletByAddress :one

SELECT EXISTS(
    SELECT 1 FROM wallets WHERE address = ?
) as exists_flag
`

// ============================================================================
// 지갑 존재 여부 체크
// ============================================================================
// 지갑 주소 중복 체크 (address는 lower-case로 전달)
func (q *Queries) ExistsWalletByAddress(ctx context.Context, address string) (bool, error) {
	row := q.db.QueryRowContext(ctx, existsWalletByAddress, address)
	var exists_flag bool
	err := row.Scan(&exists_flag)
	return exists_flag, err
}

const getPrimaryWallet = `-- name: GetPrimaryWallet :one
SELECT id, user_id, address, label, is_primary, is_verified, created_at, updated_at, external_id FROM wallets
WHERE user_id = ? AND is_primary = true
LIMIT 1
`

// 사용자의 Primary 지갑 조회
func (q *Queries) GetPrimaryWallet(ctx context.Context, userID uint64) (Wallet, error) {
	row := q.db.QueryRowContext(ctx, getPrimaryWallet, userID)
	var i Wallet
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Address,
		&i.Label,
		&i.IsPrimary,
		&i.IsVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExternalID,
	)
	return i, err
}

const getWalletByAddress = `-- name: GetWalletByAddress :one
SELECT id, user_id, address, label, is_primary, is_verified, created_at, updated_at, external_id FROM wallets WHERE address = ?
`

// 주소로 지갑 조회 (address는 lower-case로 전달)
func (q *Queries) GetWalletByAddress(ctx context.Context, address string) (Wallet, error) {
	row := q.db.QueryRowContext(ctx, getWalletByAddress, address)
	var i Wallet
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Address,
		&i.Label,
		&i.IsPrimary,
		&i.IsVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExternalID,
	)
	return i, err
}

const getWalletByExternalID = `-- name: GetWalletByExternalID :one
SELECT id, user_id, address, label, is_primary, is_verified, created_at, updated_at, external_id FROM wallets WHERE external_id = ?
`

// 외부 식별자로 지갑 조회
func (q *Queries) GetWalletByExternalID(ctx context.Context, externalID string) (Wallet, error) {
	row := q.db.QueryRowContext(ctx, getWalletByExternalID, externalID)
	var i Wallet
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Address,
		&i.Label,
		&i.IsPrimary,
		&i.IsVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExternalID,
	)
	return i, err
}

const getWalletByExternalIDAndUser = `-- name: GetWalletByExternalIDAndUser :one
SELECT w.id, w.user_id, w.address, w.label, w.is_primary, w.is_verified, w.created_at, w.updated_at, w.external_id FROM wallets w
JOIN users u ON w.user_id = u.id
WHERE w.external_id = ? AND u.external_id = ?
`

type GetWalletByExternalIDAndUserParams struct {
	ExternalID   string         `json:"external_id"`
	ExternalID_2 sql.NullString `json:"external_id_2"`
}

// 외부 식별자 + 사용자 소유권 검증 조회 (외부 API용)
func (q *Queries) GetWalletByExternalIDAndUser(ctx context.Context, arg GetWalletByExternalIDAndUserParams) (Wallet, error) {
	row := q.db.QueryRowContext(ctx, getWalletByExternalIDAndUser, arg.ExternalID, arg.ExternalID_2)
	var i Wallet
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Address,
		&i.Label,
		&i.IsPrimary,
		&i.IsVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExternalID,
	)
	return i, err
}

const getWalletByID = `-- name: GetWalletByID :one
SELECT id, user_id, address, label, is_primary, is_verified, created_at, updated_at, external_id FROM wallets WHERE id = ?
`

// ID로 지갑 조회 (내부 전용 - 외부 API에서는 사용 금지)
func (q *Queries) GetWalletByID(ctx context.Context, id uint64) (Wallet, error) {
	row := q.db.QueryRowContext(ctx, getWalletByID, id)
	var i Wallet
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Address,
		&i.Label,
		&i.IsPrimary,
		&i.IsVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExternalID,
	)
	return i, err
}

const getWalletByIDAndUser = `-- name: GetWalletByIDAndUser :one
SELECT id, user_id, address, label, is_primary, is_verified, created_at, updated_at, external_id FROM wallets
WHERE id = ? AND user_id = ?
`

type GetWalletByIDAndUserParams struct {
	ID     uint64 `json:"id"`
	UserID uint64 `json:"user_id"`
}

// ID + 사용자 소유권 검증 조회 (내부용)
func (q *Queries) GetWalletByIDAndUser(ctx context.Context, arg GetWalletByIDAndUserParams) (Wallet, error) {
	row := q.db.QueryRowContext(ctx, getWalletByIDAndUser, arg.ID, arg.UserID)
	var i Wallet
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Address,
		&i.Label,
		&i.IsPrimary,
		&i.IsVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExternalID,
	)
	return i, err
}

const getWalletForUpdate = `-- name: GetWalletForUpdate :one
SELECT id, user_id, address, label, is_primary, is_verified, created_at, updated_at, external_id FROM wallets
WHERE id = ? AND user_id = ?
FOR UPDATE
`

type GetWalletForUpdateParams struct {
	ID     uint64 `json:"id"`
	UserID uint64 `json:"user_id"`
}

// 트랜잭션 내 row-lock (검증, Primary 설정 등)
func (q *Queries) GetWalletForUpdate(ctx context.Context, arg GetWalletForUpdateParams) (Wallet, error) {
	row := q.db.QueryRowContext(ctx, getWalletForUpdate, arg.ID, arg.UserID)
	var i Wallet
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Address,
		&i.Label,
		&i.IsPrimary,
		&i.IsVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExternalID,
	)
	return i, err
}

const hardDeleteWallet = `-- name: HardDeleteWallet :execresult

DELETE FROM wallets
WHERE id = ? AND user_id = ? AND is_primary = false
`

type HardDeleteWalletParams struct {
	ID     uint64 `json:"id"`
	UserID uint64 `json:"user_id"`
}

// ============================================================================
// 지갑 삭제
// ============================================================================
// TODO: Phase 6 이후 소프트 삭제(deleted_at 컬럼) 전환 검토
// Primary 지갑은 삭제 불가 (is_primary = false 조건)
func (q *Queries) HardDeleteWallet(ctx context.Context, arg HardDeleteWalletParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, hardDeleteWallet, arg.ID, arg.UserID)
}

const listWalletsByUser = `-- name: ListWalletsByUser :many
SELECT id, user_id, address, label, is_primary, is_verified, created_at, updated_at, external_id FROM wallets
WHERE user_id = ?
ORDER BY is_primary DESC, created_at ASC
`

// 사용자의 전체 지갑 목록
func (q *Queries) ListWalletsByUser(ctx context.Context, userID uint64) ([]Wallet, error) {
	rows, err := q.db.QueryContext(ctx, listWalletsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Wallet{}
	for rows.Next() {
		var i Wallet
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Address,
			&i.Label,
			&i.IsPrimary,
			&i.IsVerified,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ExternalID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWalletsByUserExternalID = `-- name: ListWalletsByUserExternalID :many
SELECT w.id, w.user_id, w.address, w.label, w.is_primary, w.is_verified, w.created_at, w.updated_at, w.external_id FROM wallets w
JOIN users u ON w.user_id = u.id
WHERE u.external_id = ?
ORDER BY w.is_primary DESC, w.created_at ASC
`

// 사용자 external_id로 지갑 목록 조회 (외부 API용)
func (q *Queries) ListWalletsByUserExternalID(ctx context.Context, externalID sql.NullString) ([]Wallet, error) {
	rows, err := q.db.QueryContext(ctx, listWalletsByUserExternalID, externalID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Wallet{}
	for rows.Next() {
		var i Wallet
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Address,
			&i.Label,
			&i.IsPrimary,
			&i.IsVerified,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ExternalID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setWalletPrimary = `-- name: SetWalletPrimary :execresult
UPDATE wallets
SET is_primary = true, updated_at = NOW()
WHERE id = ? AND user_id = ? AND is_verified = true
`

type SetWalletPrimaryParams struct {
	ID     uint64 `json:"id"`
	UserID uint64 `json:"user_id"`
}

// 새 Primary 지갑 설정 (소유권 + 검증 상태 확인)
// SetPrimary 트랜잭션: 1) GetUserForUpdate 2) ClearPrimaryWallet 3) SetWalletPrimary
func (q *Queries) SetWalletPrimary(ctx context.Context, arg SetWalletPrimaryParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, setWalletPrimary, arg.ID, arg.UserID)
}

const updateWalletLabel = `-- name: UpdateWalletLabel :execresult
UPDATE wallets
SET label = ?, updated_at = NOW()
WHERE id = ? AND user_id = ?
`

type UpdateWalletLabelParams struct {
	Label  sql.NullString `json:"label"`
	ID     uint64         `json:"id"`
	UserID uint64         `json:"user_id"`
}

// 지갑 라벨 변경
func (q *Queries) UpdateWalletLabel(ctx context.Context, arg UpdateWalletLabelParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateWalletLabel, arg.Label, arg.ID, arg.UserID)
}

const updateWalletVerified = `-- name: UpdateWalletVerified :execresult

UPDATE wallets
SET is_verified = true, updated_at = NOW()
WHERE id = ? AND user_id = ? AND is_verified = false
`

type UpdateWalletVerifiedParams struct {
	ID     uint64 `json:"id"`
	UserID uint64 `json:"user_id"`
}

// ============================================================================
// 지갑 상태 업데이트 (:execresult로 RowsAffected 검증 가능)
// ============================================================================
// EIP-712 서명 검증 완료
func (q *Queries) UpdateWalletVerified(ctx context.Context, arg UpdateWalletVerifiedParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateWalletVerified, arg.ID, arg.UserID)
}
