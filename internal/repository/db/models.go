// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package db

import (
	"database/sql"
	"database/sql/driver"
	"encoding/json"
	"fmt"
	"time"
)

type AccountsAccountType string

const (
	AccountsAccountTypeUSER     AccountsAccountType = "USER"
	AccountsAccountTypeMERCHANT AccountsAccountType = "MERCHANT"
	AccountsAccountTypeESCROW   AccountsAccountType = "ESCROW"
	AccountsAccountTypeSYSTEM   AccountsAccountType = "SYSTEM"
)

func (e *AccountsAccountType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AccountsAccountType(s)
	case string:
		*e = AccountsAccountType(s)
	default:
		return fmt.Errorf("unsupported scan type for AccountsAccountType: %T", src)
	}
	return nil
}

type NullAccountsAccountType struct {
	AccountsAccountType AccountsAccountType `json:"accounts_account_type"`
	Valid               bool                `json:"valid"` // Valid is true if AccountsAccountType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAccountsAccountType) Scan(value interface{}) error {
	if value == nil {
		ns.AccountsAccountType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AccountsAccountType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAccountsAccountType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AccountsAccountType), nil
}

type AccountsStatus string

const (
	AccountsStatusACTIVE    AccountsStatus = "ACTIVE"
	AccountsStatusSUSPENDED AccountsStatus = "SUSPENDED"
	AccountsStatusCLOSED    AccountsStatus = "CLOSED"
)

func (e *AccountsStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AccountsStatus(s)
	case string:
		*e = AccountsStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for AccountsStatus: %T", src)
	}
	return nil
}

type NullAccountsStatus struct {
	AccountsStatus AccountsStatus `json:"accounts_status"`
	Valid          bool           `json:"valid"` // Valid is true if AccountsStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAccountsStatus) Scan(value interface{}) error {
	if value == nil {
		ns.AccountsStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AccountsStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAccountsStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AccountsStatus), nil
}

type DepositsStatus string

const (
	DepositsStatusDETECTED   DepositsStatus = "DETECTED"
	DepositsStatusCONFIRMING DepositsStatus = "CONFIRMING"
	DepositsStatusCREDITED   DepositsStatus = "CREDITED"
	DepositsStatusCOMPLETED  DepositsStatus = "COMPLETED"
	DepositsStatusFAILED     DepositsStatus = "FAILED"
)

func (e *DepositsStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = DepositsStatus(s)
	case string:
		*e = DepositsStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for DepositsStatus: %T", src)
	}
	return nil
}

type NullDepositsStatus struct {
	DepositsStatus DepositsStatus `json:"deposits_status"`
	Valid          bool           `json:"valid"` // Valid is true if DepositsStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullDepositsStatus) Scan(value interface{}) error {
	if value == nil {
		ns.DepositsStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.DepositsStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullDepositsStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.DepositsStatus), nil
}

type InventoryLogsEventType string

const (
	InventoryLogsEventTypeINBOUND  InventoryLogsEventType = "INBOUND"
	InventoryLogsEventTypeOUTBOUND InventoryLogsEventType = "OUTBOUND"
	InventoryLogsEventTypeRESERVE  InventoryLogsEventType = "RESERVE"
	InventoryLogsEventTypeRELEASE  InventoryLogsEventType = "RELEASE"
	InventoryLogsEventTypeADJUST   InventoryLogsEventType = "ADJUST"
)

func (e *InventoryLogsEventType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = InventoryLogsEventType(s)
	case string:
		*e = InventoryLogsEventType(s)
	default:
		return fmt.Errorf("unsupported scan type for InventoryLogsEventType: %T", src)
	}
	return nil
}

type NullInventoryLogsEventType struct {
	InventoryLogsEventType InventoryLogsEventType `json:"inventory_logs_event_type"`
	Valid                  bool                   `json:"valid"` // Valid is true if InventoryLogsEventType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullInventoryLogsEventType) Scan(value interface{}) error {
	if value == nil {
		ns.InventoryLogsEventType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.InventoryLogsEventType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullInventoryLogsEventType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.InventoryLogsEventType), nil
}

type LedgerEntriesEntryType string

const (
	LedgerEntriesEntryTypeDEBIT  LedgerEntriesEntryType = "DEBIT"
	LedgerEntriesEntryTypeCREDIT LedgerEntriesEntryType = "CREDIT"
)

func (e *LedgerEntriesEntryType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = LedgerEntriesEntryType(s)
	case string:
		*e = LedgerEntriesEntryType(s)
	default:
		return fmt.Errorf("unsupported scan type for LedgerEntriesEntryType: %T", src)
	}
	return nil
}

type NullLedgerEntriesEntryType struct {
	LedgerEntriesEntryType LedgerEntriesEntryType `json:"ledger_entries_entry_type"`
	Valid                  bool                   `json:"valid"` // Valid is true if LedgerEntriesEntryType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullLedgerEntriesEntryType) Scan(value interface{}) error {
	if value == nil {
		ns.LedgerEntriesEntryType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.LedgerEntriesEntryType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullLedgerEntriesEntryType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.LedgerEntriesEntryType), nil
}

type OrdersStatus string

const (
	OrdersStatusPENDING   OrdersStatus = "PENDING"
	OrdersStatusCONFIRMED OrdersStatus = "CONFIRMED"
	OrdersStatusPAID      OrdersStatus = "PAID"
	OrdersStatusSHIPPED   OrdersStatus = "SHIPPED"
	OrdersStatusCOMPLETED OrdersStatus = "COMPLETED"
	OrdersStatusCANCELLED OrdersStatus = "CANCELLED"
	OrdersStatusREFUNDED  OrdersStatus = "REFUNDED"
)

func (e *OrdersStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = OrdersStatus(s)
	case string:
		*e = OrdersStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for OrdersStatus: %T", src)
	}
	return nil
}

type NullOrdersStatus struct {
	OrdersStatus OrdersStatus `json:"orders_status"`
	Valid        bool         `json:"valid"` // Valid is true if OrdersStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullOrdersStatus) Scan(value interface{}) error {
	if value == nil {
		ns.OrdersStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.OrdersStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullOrdersStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.OrdersStatus), nil
}

type OutboxStatus string

const (
	OutboxStatusPENDING    OutboxStatus = "PENDING"
	OutboxStatusPROCESSING OutboxStatus = "PROCESSING"
	OutboxStatusCOMPLETED  OutboxStatus = "COMPLETED"
	OutboxStatusFAILED     OutboxStatus = "FAILED"
	OutboxStatusDEADLETTER OutboxStatus = "DEAD_LETTER"
)

func (e *OutboxStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = OutboxStatus(s)
	case string:
		*e = OutboxStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for OutboxStatus: %T", src)
	}
	return nil
}

type NullOutboxStatus struct {
	OutboxStatus OutboxStatus `json:"outbox_status"`
	Valid        bool         `json:"valid"` // Valid is true if OutboxStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullOutboxStatus) Scan(value interface{}) error {
	if value == nil {
		ns.OutboxStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.OutboxStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullOutboxStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.OutboxStatus), nil
}

type PaymentsStatus string

const (
	PaymentsStatusPENDING    PaymentsStatus = "PENDING"
	PaymentsStatusAUTHORIZED PaymentsStatus = "AUTHORIZED"
	PaymentsStatusCAPTURED   PaymentsStatus = "CAPTURED"
	PaymentsStatusVOIDED     PaymentsStatus = "VOIDED"
	PaymentsStatusREFUNDED   PaymentsStatus = "REFUNDED"
	PaymentsStatusFAILED     PaymentsStatus = "FAILED"
)

func (e *PaymentsStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PaymentsStatus(s)
	case string:
		*e = PaymentsStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for PaymentsStatus: %T", src)
	}
	return nil
}

type NullPaymentsStatus struct {
	PaymentsStatus PaymentsStatus `json:"payments_status"`
	Valid          bool           `json:"valid"` // Valid is true if PaymentsStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPaymentsStatus) Scan(value interface{}) error {
	if value == nil {
		ns.PaymentsStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PaymentsStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPaymentsStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PaymentsStatus), nil
}

type ProductsStatus string

const (
	ProductsStatusACTIVE   ProductsStatus = "ACTIVE"
	ProductsStatusINACTIVE ProductsStatus = "INACTIVE"
)

func (e *ProductsStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ProductsStatus(s)
	case string:
		*e = ProductsStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for ProductsStatus: %T", src)
	}
	return nil
}

type NullProductsStatus struct {
	ProductsStatus ProductsStatus `json:"products_status"`
	Valid          bool           `json:"valid"` // Valid is true if ProductsStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullProductsStatus) Scan(value interface{}) error {
	if value == nil {
		ns.ProductsStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ProductsStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullProductsStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ProductsStatus), nil
}

type SettlementsStatus string

const (
	SettlementsStatusPENDING    SettlementsStatus = "PENDING"
	SettlementsStatusPROCESSING SettlementsStatus = "PROCESSING"
	SettlementsStatusCOMPLETED  SettlementsStatus = "COMPLETED"
	SettlementsStatusFAILED     SettlementsStatus = "FAILED"
)

func (e *SettlementsStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = SettlementsStatus(s)
	case string:
		*e = SettlementsStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for SettlementsStatus: %T", src)
	}
	return nil
}

type NullSettlementsStatus struct {
	SettlementsStatus SettlementsStatus `json:"settlements_status"`
	Valid             bool              `json:"valid"` // Valid is true if SettlementsStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullSettlementsStatus) Scan(value interface{}) error {
	if value == nil {
		ns.SettlementsStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.SettlementsStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullSettlementsStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.SettlementsStatus), nil
}

type SystemWalletsWalletType string

const (
	SystemWalletsWalletTypeTREASURY   SystemWalletsWalletType = "TREASURY"
	SystemWalletsWalletTypeMINTER     SystemWalletsWalletType = "MINTER"
	SystemWalletsWalletTypeBURNER     SystemWalletsWalletType = "BURNER"
	SystemWalletsWalletTypeHOTWALLET  SystemWalletsWalletType = "HOT_WALLET"
	SystemWalletsWalletTypeCOLDWALLET SystemWalletsWalletType = "COLD_WALLET"
)

func (e *SystemWalletsWalletType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = SystemWalletsWalletType(s)
	case string:
		*e = SystemWalletsWalletType(s)
	default:
		return fmt.Errorf("unsupported scan type for SystemWalletsWalletType: %T", src)
	}
	return nil
}

type NullSystemWalletsWalletType struct {
	SystemWalletsWalletType SystemWalletsWalletType `json:"system_wallets_wallet_type"`
	Valid                   bool                    `json:"valid"` // Valid is true if SystemWalletsWalletType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullSystemWalletsWalletType) Scan(value interface{}) error {
	if value == nil {
		ns.SystemWalletsWalletType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.SystemWalletsWalletType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullSystemWalletsWalletType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.SystemWalletsWalletType), nil
}

type UsersKycStatus string

const (
	UsersKycStatusNONE     UsersKycStatus = "NONE"
	UsersKycStatusPENDING  UsersKycStatus = "PENDING"
	UsersKycStatusVERIFIED UsersKycStatus = "VERIFIED"
	UsersKycStatusREJECTED UsersKycStatus = "REJECTED"
)

func (e *UsersKycStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = UsersKycStatus(s)
	case string:
		*e = UsersKycStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for UsersKycStatus: %T", src)
	}
	return nil
}

type NullUsersKycStatus struct {
	UsersKycStatus UsersKycStatus `json:"users_kyc_status"`
	Valid          bool           `json:"valid"` // Valid is true if UsersKycStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullUsersKycStatus) Scan(value interface{}) error {
	if value == nil {
		ns.UsersKycStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.UsersKycStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullUsersKycStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.UsersKycStatus), nil
}

type UsersRole string

const (
	UsersRoleBUYER  UsersRole = "BUYER"
	UsersRoleSELLER UsersRole = "SELLER"
	UsersRoleBOTH   UsersRole = "BOTH"
	UsersRoleADMIN  UsersRole = "ADMIN"
)

func (e *UsersRole) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = UsersRole(s)
	case string:
		*e = UsersRole(s)
	default:
		return fmt.Errorf("unsupported scan type for UsersRole: %T", src)
	}
	return nil
}

type NullUsersRole struct {
	UsersRole UsersRole `json:"users_role"`
	Valid     bool      `json:"valid"` // Valid is true if UsersRole is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullUsersRole) Scan(value interface{}) error {
	if value == nil {
		ns.UsersRole, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.UsersRole.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullUsersRole) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.UsersRole), nil
}

type UsersStatus string

const (
	UsersStatusACTIVE    UsersStatus = "ACTIVE"
	UsersStatusSUSPENDED UsersStatus = "SUSPENDED"
	UsersStatusDELETED   UsersStatus = "DELETED"
)

func (e *UsersStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = UsersStatus(s)
	case string:
		*e = UsersStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for UsersStatus: %T", src)
	}
	return nil
}

type NullUsersStatus struct {
	UsersStatus UsersStatus `json:"users_status"`
	Valid       bool        `json:"valid"` // Valid is true if UsersStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullUsersStatus) Scan(value interface{}) error {
	if value == nil {
		ns.UsersStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.UsersStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullUsersStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.UsersStatus), nil
}

type WithdrawalsStatus string

const (
	WithdrawalsStatusPENDING   WithdrawalsStatus = "PENDING"
	WithdrawalsStatusAPPROVED  WithdrawalsStatus = "APPROVED"
	WithdrawalsStatusSUBMITTED WithdrawalsStatus = "SUBMITTED"
	WithdrawalsStatusCONFIRMED WithdrawalsStatus = "CONFIRMED"
	WithdrawalsStatusCOMPLETED WithdrawalsStatus = "COMPLETED"
	WithdrawalsStatusREJECTED  WithdrawalsStatus = "REJECTED"
	WithdrawalsStatusFAILED    WithdrawalsStatus = "FAILED"
)

func (e *WithdrawalsStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WithdrawalsStatus(s)
	case string:
		*e = WithdrawalsStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for WithdrawalsStatus: %T", src)
	}
	return nil
}

type NullWithdrawalsStatus struct {
	WithdrawalsStatus WithdrawalsStatus `json:"withdrawals_status"`
	Valid             bool              `json:"valid"` // Valid is true if WithdrawalsStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWithdrawalsStatus) Scan(value interface{}) error {
	if value == nil {
		ns.WithdrawalsStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WithdrawalsStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWithdrawalsStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WithdrawalsStatus), nil
}

type Account struct {
	ID              uint64              `json:"id"`
	AccountType     AccountsAccountType `json:"account_type"`
	OwnerID         sql.NullInt64       `json:"owner_id"`
	PrimaryWalletID sql.NullInt64       `json:"primary_wallet_id"`
	ExternalID      sql.NullString      `json:"external_id"`
	Balance         string              `json:"balance"`
	HoldBalance     string              `json:"hold_balance"`
	Version         uint32              `json:"version"`
	Status          AccountsStatus      `json:"status"`
	CreatedAt       time.Time           `json:"created_at"`
	UpdatedAt       time.Time           `json:"updated_at"`
}

type AuditLog struct {
	ID           uint64          `json:"id"`
	ActorType    string          `json:"actor_type"`
	ActorID      sql.NullInt64   `json:"actor_id"`
	Action       string          `json:"action"`
	ResourceType string          `json:"resource_type"`
	ResourceID   sql.NullInt64   `json:"resource_id"`
	OldValue     json.RawMessage `json:"old_value"`
	NewValue     json.RawMessage `json:"new_value"`
	IpAddress    sql.NullString  `json:"ip_address"`
	UserAgent    sql.NullString  `json:"user_agent"`
	RequestID    sql.NullString  `json:"request_id"`
	CreatedAt    time.Time       `json:"created_at"`
}

type Deposit struct {
	ID          uint64         `json:"id"`
	UserID      uint64         `json:"user_id"`
	AccountID   uint64         `json:"account_id"`
	TxHash      string         `json:"tx_hash"`
	FromAddress string         `json:"from_address"`
	Amount      string         `json:"amount"`
	BlockNumber sql.NullInt64  `json:"block_number"`
	Status      DepositsStatus `json:"status"`
	ConfirmedAt sql.NullTime   `json:"confirmed_at"`
	CreatedAt   time.Time      `json:"created_at"`
	UpdatedAt   time.Time      `json:"updated_at"`
}

type IdempotencyKey struct {
	ID             uint64         `json:"id"`
	IdempotencyKey string         `json:"idempotency_key"`
	RequestPath    string         `json:"request_path"`
	RequestHash    string         `json:"request_hash"`
	ResponseStatus sql.NullInt32  `json:"response_status"`
	ResponseBody   sql.NullString `json:"response_body"`
	CreatedAt      time.Time      `json:"created_at"`
	ExpiresAt      time.Time      `json:"expires_at"`
}

type Inventory struct {
	ID               uint64    `json:"id"`
	ProductID        uint64    `json:"product_id"`
	Location         string    `json:"location"`
	Quantity         int64     `json:"quantity"`
	ReservedQuantity int64     `json:"reserved_quantity"`
	Version          uint32    `json:"version"`
	CreatedAt        time.Time `json:"created_at"`
	UpdatedAt        time.Time `json:"updated_at"`
}

type InventoryLog struct {
	ID             uint64                 `json:"id"`
	InventoryID    uint64                 `json:"inventory_id"`
	EventType      InventoryLogsEventType `json:"event_type"`
	QuantityChange int64                  `json:"quantity_change"`
	QuantityAfter  int64                  `json:"quantity_after"`
	ReservedAfter  int64                  `json:"reserved_after"`
	ReferenceType  sql.NullString         `json:"reference_type"`
	ReferenceID    sql.NullInt64          `json:"reference_id"`
	Reason         sql.NullString         `json:"reason"`
	CreatedAt      time.Time              `json:"created_at"`
}

type LedgerEntry struct {
	ID            uint64                 `json:"id"`
	TxID          string                 `json:"tx_id"`
	AccountID     uint64                 `json:"account_id"`
	EntryType     LedgerEntriesEntryType `json:"entry_type"`
	Amount        string                 `json:"amount"`
	BalanceAfter  string                 `json:"balance_after"`
	ReferenceType sql.NullString         `json:"reference_type"`
	ReferenceID   sql.NullInt64          `json:"reference_id"`
	Description   sql.NullString         `json:"description"`
	CreatedAt     time.Time              `json:"created_at"`
}

type Order struct {
	ID          uint64       `json:"id"`
	OrderNumber string       `json:"order_number"`
	BuyerID     uint64       `json:"buyer_id"`
	SellerID    uint64       `json:"seller_id"`
	Status      OrdersStatus `json:"status"`
	TotalAmount string       `json:"total_amount"`
	CreatedAt   time.Time    `json:"created_at"`
	UpdatedAt   time.Time    `json:"updated_at"`
}

type OrderItem struct {
	ID        uint64    `json:"id"`
	OrderID   uint64    `json:"order_id"`
	ProductID uint64    `json:"product_id"`
	Quantity  uint32    `json:"quantity"`
	UnitPrice string    `json:"unit_price"`
	CreatedAt time.Time `json:"created_at"`
}

type Outbox struct {
	ID            uint64          `json:"id"`
	EventType     string          `json:"event_type"`
	AggregateType string          `json:"aggregate_type"`
	AggregateID   uint64          `json:"aggregate_id"`
	Payload       json.RawMessage `json:"payload"`
	Status        OutboxStatus    `json:"status"`
	RetryCount    uint32          `json:"retry_count"`
	MaxRetries    uint32          `json:"max_retries"`
	NextRetryAt   sql.NullTime    `json:"next_retry_at"`
	ErrorMessage  sql.NullString  `json:"error_message"`
	CreatedAt     time.Time       `json:"created_at"`
	UpdatedAt     time.Time       `json:"updated_at"`
}

type Payment struct {
	ID             uint64         `json:"id"`
	IdempotencyKey string         `json:"idempotency_key"`
	OrderID        uint64         `json:"order_id"`
	PayerAccountID uint64         `json:"payer_account_id"`
	Amount         string         `json:"amount"`
	Status         PaymentsStatus `json:"status"`
	AuthorizedAt   sql.NullTime   `json:"authorized_at"`
	CapturedAt     sql.NullTime   `json:"captured_at"`
	ExpiresAt      sql.NullTime   `json:"expires_at"`
	CreatedAt      time.Time      `json:"created_at"`
	UpdatedAt      time.Time      `json:"updated_at"`
}

type Product struct {
	ID        uint64         `json:"id"`
	Sku       string         `json:"sku"`
	Name      string         `json:"name"`
	Price     string         `json:"price"`
	Status    ProductsStatus `json:"status"`
	CreatedAt time.Time      `json:"created_at"`
	UpdatedAt time.Time      `json:"updated_at"`
}

type Settlement struct {
	ID             uint64            `json:"id"`
	PaymentID      uint64            `json:"payment_id"`
	PayeeAccountID uint64            `json:"payee_account_id"`
	Amount         string            `json:"amount"`
	FeeAmount      string            `json:"fee_amount"`
	NetAmount      string            `json:"net_amount"`
	Status         SettlementsStatus `json:"status"`
	SettledAt      sql.NullTime      `json:"settled_at"`
	CreatedAt      time.Time         `json:"created_at"`
	UpdatedAt      time.Time         `json:"updated_at"`
}

type SystemWallet struct {
	ID          uint64                  `json:"id"`
	WalletType  SystemWalletsWalletType `json:"wallet_type"`
	Address     string                  `json:"address"`
	Description sql.NullString          `json:"description"`
	IsActive    bool                    `json:"is_active"`
	CreatedAt   time.Time               `json:"created_at"`
	UpdatedAt   time.Time               `json:"updated_at"`
}

type User struct {
	ID            uint64         `json:"id"`
	Email         string         `json:"email"`
	ExternalID    sql.NullString `json:"external_id"`
	Name          string         `json:"name"`
	Phone         sql.NullString `json:"phone"`
	Role          UsersRole      `json:"role"`
	KycStatus     UsersKycStatus `json:"kyc_status"`
	KycVerifiedAt sql.NullTime   `json:"kyc_verified_at"`
	Status        UsersStatus    `json:"status"`
	CreatedAt     time.Time      `json:"created_at"`
	UpdatedAt     time.Time      `json:"updated_at"`
}

type Wallet struct {
	ID         uint64         `json:"id"`
	UserID     uint64         `json:"user_id"`
	Address    string         `json:"address"`
	Label      sql.NullString `json:"label"`
	IsPrimary  bool           `json:"is_primary"`
	IsVerified bool           `json:"is_verified"`
	CreatedAt  time.Time      `json:"created_at"`
	UpdatedAt  time.Time      `json:"updated_at"`
	ExternalID string         `json:"external_id"`
}

type Withdrawal struct {
	ID          uint64            `json:"id"`
	UserID      uint64            `json:"user_id"`
	AccountID   uint64            `json:"account_id"`
	ToAddress   string            `json:"to_address"`
	Amount      string            `json:"amount"`
	FeeAmount   string            `json:"fee_amount"`
	Status      WithdrawalsStatus `json:"status"`
	TxHash      sql.NullString    `json:"tx_hash"`
	SubmittedAt sql.NullTime      `json:"submitted_at"`
	ConfirmedAt sql.NullTime      `json:"confirmed_at"`
	CreatedAt   time.Time         `json:"created_at"`
	UpdatedAt   time.Time         `json:"updated_at"`
}
