// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: ledger.sql

package db

import (
	"context"
	"database/sql"
)

const createLedgerEntry = `-- name: CreateLedgerEntry :execresult
INSERT INTO ledger_entries (tx_id, account_id, entry_type, amount, balance_after, description, idempotency_key)
VALUES (?, ?, ?, ?, ?, ?, ?)
`

type CreateLedgerEntryParams struct {
	TxID           string                 `json:"tx_id"`
	AccountID      uint64                 `json:"account_id"`
	EntryType      LedgerEntriesEntryType `json:"entry_type"`
	Amount         string                 `json:"amount"`
	BalanceAfter   string                 `json:"balance_after"`
	Description    sql.NullString         `json:"description"`
	IdempotencyKey sql.NullString         `json:"idempotency_key"`
}

func (q *Queries) CreateLedgerEntry(ctx context.Context, arg CreateLedgerEntryParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createLedgerEntry,
		arg.TxID,
		arg.AccountID,
		arg.EntryType,
		arg.Amount,
		arg.BalanceAfter,
		arg.Description,
		arg.IdempotencyKey,
	)
}

const getLedgerEntriesByAccount = `-- name: GetLedgerEntriesByAccount :many
SELECT id, tx_id, account_id, entry_type, amount, balance_after, description, idempotency_key, created_at FROM ledger_entries
WHERE account_id = ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type GetLedgerEntriesByAccountParams struct {
	AccountID uint64 `json:"account_id"`
	Limit     int32  `json:"limit"`
	Offset    int32  `json:"offset"`
}

func (q *Queries) GetLedgerEntriesByAccount(ctx context.Context, arg GetLedgerEntriesByAccountParams) ([]LedgerEntry, error) {
	rows, err := q.db.QueryContext(ctx, getLedgerEntriesByAccount, arg.AccountID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LedgerEntry{}
	for rows.Next() {
		var i LedgerEntry
		if err := rows.Scan(
			&i.ID,
			&i.TxID,
			&i.AccountID,
			&i.EntryType,
			&i.Amount,
			&i.BalanceAfter,
			&i.Description,
			&i.IdempotencyKey,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLedgerEntriesByTxID = `-- name: GetLedgerEntriesByTxID :many
SELECT id, tx_id, account_id, entry_type, amount, balance_after, description, idempotency_key, created_at FROM ledger_entries WHERE tx_id = ? ORDER BY id
`

func (q *Queries) GetLedgerEntriesByTxID(ctx context.Context, txID string) ([]LedgerEntry, error) {
	rows, err := q.db.QueryContext(ctx, getLedgerEntriesByTxID, txID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LedgerEntry{}
	for rows.Next() {
		var i LedgerEntry
		if err := rows.Scan(
			&i.ID,
			&i.TxID,
			&i.AccountID,
			&i.EntryType,
			&i.Amount,
			&i.BalanceAfter,
			&i.Description,
			&i.IdempotencyKey,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLedgerEntryByIdempotencyKey = `-- name: GetLedgerEntryByIdempotencyKey :one
SELECT id, tx_id, account_id, entry_type, amount, balance_after, description, idempotency_key, created_at FROM ledger_entries WHERE idempotency_key = ? LIMIT 1
`

func (q *Queries) GetLedgerEntryByIdempotencyKey(ctx context.Context, idempotencyKey sql.NullString) (LedgerEntry, error) {
	row := q.db.QueryRowContext(ctx, getLedgerEntryByIdempotencyKey, idempotencyKey)
	var i LedgerEntry
	err := row.Scan(
		&i.ID,
		&i.TxID,
		&i.AccountID,
		&i.EntryType,
		&i.Amount,
		&i.BalanceAfter,
		&i.Description,
		&i.IdempotencyKey,
		&i.CreatedAt,
	)
	return i, err
}

const sumLedgerEntriesByType = `-- name: SumLedgerEntriesByType :one
SELECT
    COALESCE(SUM(CASE WHEN entry_type = 'CREDIT' THEN amount ELSE 0 END), 0) as total_credits,
    COALESCE(SUM(CASE WHEN entry_type = 'DEBIT' THEN amount ELSE 0 END), 0) as total_debits
FROM ledger_entries
WHERE account_id = ?
`

type SumLedgerEntriesByTypeRow struct {
	TotalCredits interface{} `json:"total_credits"`
	TotalDebits  interface{} `json:"total_debits"`
}

func (q *Queries) SumLedgerEntriesByType(ctx context.Context, accountID uint64) (SumLedgerEntriesByTypeRow, error) {
	row := q.db.QueryRowContext(ctx, sumLedgerEntriesByType, accountID)
	var i SumLedgerEntriesByTypeRow
	err := row.Scan(&i.TotalCredits, &i.TotalDebits)
	return i, err
}
