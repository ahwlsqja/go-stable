// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: outbox.sql

package db

import (
	"context"
	"database/sql"
	"encoding/json"
)

const completeOutboxJob = `-- name: CompleteOutboxJob :exec
UPDATE outbox_jobs
SET status = 'COMPLETED', locked_until = NULL
WHERE id = ?
`

func (q *Queries) CompleteOutboxJob(ctx context.Context, id uint64) error {
	_, err := q.db.ExecContext(ctx, completeOutboxJob, id)
	return err
}

const createOutboxJob = `-- name: CreateOutboxJob :execresult
INSERT INTO outbox_jobs (job_type, reference_id, payload, status, max_retries, next_retry_at)
VALUES (?, ?, ?, 'PENDING', ?, NOW())
`

type CreateOutboxJobParams struct {
	JobType     OutboxJobsJobType `json:"job_type"`
	ReferenceID uint64            `json:"reference_id"`
	Payload     json.RawMessage   `json:"payload"`
	MaxRetries  sql.NullInt32     `json:"max_retries"`
}

func (q *Queries) CreateOutboxJob(ctx context.Context, arg CreateOutboxJobParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createOutboxJob,
		arg.JobType,
		arg.ReferenceID,
		arg.Payload,
		arg.MaxRetries,
	)
}

const failOutboxJob = `-- name: FailOutboxJob :exec
UPDATE outbox_jobs
SET status = CASE WHEN retry_count >= max_retries - 1 THEN 'DEAD_LETTER' ELSE 'FAILED' END,
    retry_count = retry_count + 1,
    next_retry_at = ?,
    error_message = ?,
    locked_until = NULL
WHERE id = ?
`

type FailOutboxJobParams struct {
	NextRetryAt  sql.NullTime   `json:"next_retry_at"`
	ErrorMessage sql.NullString `json:"error_message"`
	ID           uint64         `json:"id"`
}

func (q *Queries) FailOutboxJob(ctx context.Context, arg FailOutboxJobParams) error {
	_, err := q.db.ExecContext(ctx, failOutboxJob, arg.NextRetryAt, arg.ErrorMessage, arg.ID)
	return err
}

const getOutboxJob = `-- name: GetOutboxJob :one
SELECT id, job_type, reference_id, payload, status, retry_count, max_retries, next_retry_at, locked_until, error_message, created_at, updated_at FROM outbox_jobs WHERE id = ? LIMIT 1
`

func (q *Queries) GetOutboxJob(ctx context.Context, id uint64) (OutboxJob, error) {
	row := q.db.QueryRowContext(ctx, getOutboxJob, id)
	var i OutboxJob
	err := row.Scan(
		&i.ID,
		&i.JobType,
		&i.ReferenceID,
		&i.Payload,
		&i.Status,
		&i.RetryCount,
		&i.MaxRetries,
		&i.NextRetryAt,
		&i.LockedUntil,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOutboxJobByTypeAndRef = `-- name: GetOutboxJobByTypeAndRef :one
SELECT id, job_type, reference_id, payload, status, retry_count, max_retries, next_retry_at, locked_until, error_message, created_at, updated_at FROM outbox_jobs WHERE job_type = ? AND reference_id = ? LIMIT 1
`

type GetOutboxJobByTypeAndRefParams struct {
	JobType     OutboxJobsJobType `json:"job_type"`
	ReferenceID uint64            `json:"reference_id"`
}

func (q *Queries) GetOutboxJobByTypeAndRef(ctx context.Context, arg GetOutboxJobByTypeAndRefParams) (OutboxJob, error) {
	row := q.db.QueryRowContext(ctx, getOutboxJobByTypeAndRef, arg.JobType, arg.ReferenceID)
	var i OutboxJob
	err := row.Scan(
		&i.ID,
		&i.JobType,
		&i.ReferenceID,
		&i.Payload,
		&i.Status,
		&i.RetryCount,
		&i.MaxRetries,
		&i.NextRetryAt,
		&i.LockedUntil,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPendingOutboxJobs = `-- name: GetPendingOutboxJobs :many
SELECT id, job_type, reference_id, payload, status, retry_count, max_retries, next_retry_at, locked_until, error_message, created_at, updated_at FROM outbox_jobs
WHERE status IN ('PENDING', 'FAILED')
  AND (next_retry_at IS NULL OR next_retry_at <= NOW())
  AND (locked_until IS NULL OR locked_until <= NOW())
  AND retry_count < max_retries
ORDER BY created_at
LIMIT ?
`

func (q *Queries) GetPendingOutboxJobs(ctx context.Context, limit int32) ([]OutboxJob, error) {
	rows, err := q.db.QueryContext(ctx, getPendingOutboxJobs, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []OutboxJob{}
	for rows.Next() {
		var i OutboxJob
		if err := rows.Scan(
			&i.ID,
			&i.JobType,
			&i.ReferenceID,
			&i.Payload,
			&i.Status,
			&i.RetryCount,
			&i.MaxRetries,
			&i.NextRetryAt,
			&i.LockedUntil,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const lockOutboxJob = `-- name: LockOutboxJob :execresult
UPDATE outbox_jobs
SET status = 'PROCESSING', locked_until = ?
WHERE id = ? AND (locked_until IS NULL OR locked_until <= NOW())
`

type LockOutboxJobParams struct {
	LockedUntil sql.NullTime `json:"locked_until"`
	ID          uint64       `json:"id"`
}

func (q *Queries) LockOutboxJob(ctx context.Context, arg LockOutboxJobParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, lockOutboxJob, arg.LockedUntil, arg.ID)
}
